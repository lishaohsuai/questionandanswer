\contentsline {section}{\numberline {1}Spring}{6}% 
\contentsline {subsubsection}{\numberline {1.0.1}Spring 框架能带来哪些好处}{6}% 
\contentsline {subsubsection}{\numberline {1.0.2}介绍一下Spring, 读过源码介绍一下大致流程}{6}% 
\contentsline {subsubsection}{\numberline {1.0.3}Autowired}{6}% 
\contentsline {subsubsection}{\numberline {1.0.4}什么是控制反转(IOC)}{6}% 
\contentsline {subsubsection}{\numberline {1.0.5}什么是依赖注入?}{7}% 
\contentsline {subsubsection}{\numberline {1.0.6}Spring 对对象进行创建流程}{7}% 
\contentsline {subsubsection}{\numberline {1.0.7}什么是AOP}{7}% 
\contentsline {subsubsection}{\numberline {1.0.8}bean的生命周期}{7}% 
\contentsline {subsubsection}{\numberline {1.0.9}简单阐述SpringMVC的流程}{8}% 
\contentsline {subsubsection}{\numberline {1.0.10}第三个三级标题}{10}% 
\contentsline {section}{\numberline {2}java基础}{10}% 
\contentsline {subsubsection}{\numberline {2.0.1}如何查看线程死锁}{10}% 
\contentsline {subsubsection}{\numberline {2.0.2}线程之间如何进行通讯的}{10}% 
\contentsline {subsubsection}{\numberline {2.0.3}快速失败(fail-fast) 和 安全失败(fail-safe) 的区别是什么?}{10}% 
\contentsline {subsubsection}{\numberline {2.0.4}异常}{10}% 
\contentsline {subsubsection}{\numberline {2.0.5}synchronized的底层实现细节}{10}% 
\contentsline {subsubsection}{\numberline {2.0.6}线程池参数}{11}% 
\contentsline {subsubsection}{\numberline {2.0.7}sychronized和ReentrantLock的区别}{11}% 
\contentsline {subsubsection}{\numberline {2.0.8}线程池中使用的BlockQueue}{12}% 
\contentsline {subsubsection}{\numberline {2.0.9}Executors 工厂类实现线程池}{12}% 
\contentsline {subsubsection}{\numberline {2.0.10}线程池的拒绝策略}{13}% 
\contentsline {subsubsection}{\numberline {2.0.11}8种基本数据类型}{13}% 
\contentsline {subsubsection}{\numberline {2.0.12}Comparable \& Comparator 区别}{13}% 
\contentsline {subsubsection}{\numberline {2.0.13}java采用值传递还是引用传递?}{14}% 
\contentsline {subsubsection}{\numberline {2.0.14}java深拷贝和浅拷贝}{14}% 
\contentsline {subsubsection}{\numberline {2.0.15}java"==" 和 equals 的区别}{14}% 
\contentsline {subsubsection}{\numberline {2.0.16}String和StringBuilder, StringBuffer的区别}{14}% 
\contentsline {subsubsection}{\numberline {2.0.17}Java反射机制}{15}% 
\contentsline {subsubsection}{\numberline {2.0.18}简述面向对象三大特征, 继承, 封装, 多态}{15}% 
\contentsline {subsubsection}{\numberline {2.0.19}多态}{15}% 
\contentsline {subsubsection}{\numberline {2.0.20}内部类}{15}% 
\contentsline {subsubsection}{\numberline {2.0.21}红黑树}{15}% 
\contentsline {subsubsection}{\numberline {2.0.22}hashmap的数据结构}{16}% 
\contentsline {subsubsection}{\numberline {2.0.23}hashmap的put方法}{16}% 
\contentsline {subsubsection}{\numberline {2.0.24}介绍一下ThreadLocal}{17}% 
\contentsline {subsubsection}{\numberline {2.0.25}heap和stack有什么区别}{17}% 
\contentsline {subsubsection}{\numberline {2.0.26}Array 和 ArrayList 的区别}{17}% 
\contentsline {subsubsection}{\numberline {2.0.27}Java各种锁: 悲观锁, 泪管所, 自旋锁, 偏向锁, 轻量/重量锁, 读写锁, 可重入锁}{18}% 
\contentsline {subsubsection}{\numberline {2.0.28}Collection 和 Collections 的区别}{18}% 
\contentsline {subsubsection}{\numberline {2.0.29}接口与抽象类区别}{18}% 
\contentsline {subsubsection}{\numberline {2.0.30}ArrayList和LinkedList内部实现大致是怎样的? 他们之间的区别和优缺点}{19}% 
\contentsline {subsubsection}{\numberline {2.0.31}==和equals的区别}{20}% 
\contentsline {subsubsection}{\numberline {2.0.32}hashCode方法的作用}{20}% 
\contentsline {subsubsection}{\numberline {2.0.33}反射}{20}% 
\contentsline {subsubsection}{\numberline {2.0.34}简述Java内存模型(JMM)}{20}% 
\contentsline {subsubsection}{\numberline {2.0.35}Java内存模型中的可见性, 原子性和有序性}{20}% 
\contentsline {subsubsection}{\numberline {2.0.36}happen-before原则}{21}% 
\contentsline {subsubsection}{\numberline {2.0.37}wait/notify, await/singal}{21}% 
\contentsline {subsubsection}{\numberline {2.0.38}多线程wait和sleep区别}{21}% 
\contentsline {subsubsection}{\numberline {2.0.39}Collection<? extends Person> s}{22}% 
\contentsline {subsubsection}{\numberline {2.0.40}线程的状态有哪些?}{28}% 
\contentsline {subsubsection}{\numberline {2.0.41}创建线程的几种方式}{28}% 
\contentsline {subsubsection}{\numberline {2.0.42}synchronized锁升级: 无锁, 偏向锁, 轻量级锁, 重量级锁(与锁的优化一起学习}{29}% 
\contentsline {subsubsection}{\numberline {2.0.43}如何使用synchronized}{30}% 
\contentsline {section}{\numberline {3}JVM}{30}% 
\contentsline {subsubsection}{\numberline {3.0.1}说一下JVM中, 哪些是共享区, 哪些可以作为gc root}{30}% 
\contentsline {subsubsection}{\numberline {3.0.2}你们项目如何排查JVM问题}{31}% 
\contentsline {subsubsection}{\numberline {3.0.3}GC的三种收集方法: 标记清除, 标记整理, 复制算法的原理与特点, 分别用在什么地方, 如果让你优化收集方法, 有什么思路}{31}% 
\contentsline {subsubsection}{\numberline {3.0.4}JVM的主要组成部分及其作用?}{32}% 
\contentsline {subsubsection}{\numberline {3.0.5}JVM运行时数据区}{33}% 
\contentsline {subsubsection}{\numberline {3.0.6}JVM运行时数据区这些方法的关系}{33}% 
\contentsline {subsubsection}{\numberline {3.0.7}永久代PermGen 和 元空间Metaspace 区别}{33}% 
\contentsline {subsubsection}{\numberline {3.0.8}说一下堆栈的区别?}{35}% 
\contentsline {subsubsection}{\numberline {3.0.9}常见的垃圾收集器?}{35}% 
\contentsline {subsubsection}{\numberline {3.0.10}内存分配与回收策略. }{37}% 
\contentsline {subsubsection}{\numberline {3.0.11}虚拟机性能监控和故障处理工具}{37}% 
\contentsline {subsubsection}{\numberline {3.0.12}简述JVM中类加载机制}{37}% 
\contentsline {subsubsection}{\numberline {3.0.13}对象的访问定位?}{38}% 
\contentsline {subsubsection}{\numberline {3.0.14}垃圾回收器的基本原理是什么?}{38}% 
\contentsline {subsubsection}{\numberline {3.0.15}在java中, 对象什么时候可以被垃圾回收?}{39}% 
\contentsline {subsubsection}{\numberline {3.0.16}如何判断对象已经死亡?}{39}% 
\contentsline {subsubsection}{\numberline {3.0.17}简述强, 软, 弱, 虚引用?}{39}% 
\contentsline {section}{\numberline {4}Redis}{40}% 
\contentsline {subsubsection}{\numberline {4.0.1}什么是Redis?}{40}% 
\contentsline {subsubsection}{\numberline {4.0.2}简述Redis单线程模型?}{40}% 
\contentsline {subsubsection}{\numberline {4.0.3}Redis五种类型数据的实现方式}{40}% 
\contentsline {subsubsection}{\numberline {4.0.4}redis字典的底层实现hashTable相关问题}{42}% 
\contentsline {subsubsection}{\numberline {4.0.5}压缩链表原理ziplist}{42}% 
\contentsline {subsubsection}{\numberline {4.0.6}zset}{42}% 
\contentsline {subsubsection}{\numberline {4.0.7}AOF和RDB两种持久化方式区别}{43}% 
\contentsline {subsubsection}{\numberline {4.0.8}Redis中过期策略和缓存淘汰机制}{43}% 
\contentsline {subsubsection}{\numberline {4.0.9}为什么要使用Redis}{43}% 
\contentsline {subsubsection}{\numberline {4.0.10}Redis底层实现跳表介绍一下}{44}% 
\contentsline {subsubsection}{\numberline {4.0.11}为什么要使用Redis而不用map/guavaCache做缓存}{44}% 
\contentsline {subsubsection}{\numberline {4.0.12}分布式锁如何使用redis实现}{44}% 
\contentsline {subsubsection}{\numberline {4.0.13}Redis的内存淘汰策略有哪些}{44}% 
\contentsline {subsubsection}{\numberline {4.0.14}Redis事物的概念}{45}% 
\contentsline {subsubsection}{\numberline {4.0.15}RedisSharding}{46}% 
\contentsline {subsubsection}{\numberline {4.0.16}缓存雪崩}{46}% 
\contentsline {subsubsection}{\numberline {4.0.17}缓存穿透}{46}% 
\contentsline {subsubsection}{\numberline {4.0.18}缓存击穿}{46}% 
\contentsline {subsubsection}{\numberline {4.0.19}缓存预热}{47}% 
\contentsline {subsubsection}{\numberline {4.0.20}Redis6.0 为什么要引入多线程呢?}{47}% 
\contentsline {subsubsection}{\numberline {4.0.21}Redis主从复制模式}{47}% 
\contentsline {subsubsection}{\numberline {4.0.22}Redis中持久化机制}{47}% 
\contentsline {section}{\numberline {5}计算机网络}{48}% 
\contentsline {subsubsection}{\numberline {5.0.1}计算机网络分层}{48}% 
\contentsline {subsubsection}{\numberline {5.0.2}TCP和UDP区别?}{48}% 
\contentsline {subsubsection}{\numberline {5.0.3}TCP三次握手相关问题}{48}% 
\contentsline {subsubsection}{\numberline {5.0.4}TCP四次挥手问题}{48}% 
\contentsline {subsubsection}{\numberline {5.0.5}TCP协议-如何保证传输的可靠性}{48}% 
\contentsline {subsubsection}{\numberline {5.0.6}Cookie作用, 安全性问题和Session的比较}{49}% 
\contentsline {subsubsection}{\numberline {5.0.7}HTTP1.1 和 HTTP1.0的比较}{50}% 
\contentsline {subsubsection}{\numberline {5.0.8}HTTPS加密}{50}% 
\contentsline {subsubsection}{\numberline {5.0.9}输入网址发生的事情}{51}% 
\contentsline {section}{\numberline {6}mysql}{51}% 
\contentsline {subsubsection}{\numberline {6.0.1}隔离级别}{51}% 
\contentsline {subsubsection}{\numberline {6.0.2}ACID}{52}% 
\contentsline {subsubsection}{\numberline {6.0.3}乐观锁和悲观锁}{52}% 
\contentsline {subsubsection}{\numberline {6.0.4}MVCC}{52}% 
\contentsline {subsubsection}{\numberline {6.0.5}B+/B树之间的比较}{52}% 
\contentsline {subsubsection}{\numberline {6.0.6}聚集索引\&非聚集索引}{52}% 
\contentsline {subsubsection}{\numberline {6.0.7}创建索引的优点}{52}% 
\contentsline {subsubsection}{\numberline {6.0.8}创建索引的缺点}{53}% 
\contentsline {subsubsection}{\numberline {6.0.9}MYSQL优化}{53}% 
\contentsline {subsubsection}{\numberline {6.0.10}InnoDB \& MyISAM}{53}% 
\contentsline {subsubsection}{\numberline {6.0.11}创建存储过程}{53}% 
\contentsline {subsubsection}{\numberline {6.0.12}热备份和冷备份}{53}% 
\contentsline {subsubsection}{\numberline {6.0.13}Innode加锁}{54}% 
\contentsline {subsubsection}{\numberline {6.0.14}INNODB解决死锁}{54}% 
\contentsline {subsubsection}{\numberline {6.0.15}Mysql锁你了解哪些}{54}% 
\contentsline {subsubsection}{\numberline {6.0.16}Mysql数据库中, 什么情况下设置了索引但是无法使用?}{54}% 
\contentsline {section}{\numberline {7}操作系统}{55}% 
\contentsline {subsubsection}{\numberline {7.0.1}协程与线程进行比较}{55}% 
\contentsline {subsubsection}{\numberline {7.0.2}进程之间的通信方式有哪些?}{55}% 
\contentsline {subsubsection}{\numberline {7.0.3}进程调度算法}{55}% 
\contentsline {subsubsection}{\numberline {7.0.4}epoll和poll的区别}{55}% 
\contentsline {section}{\numberline {8}设计模式}{56}% 
\contentsline {subsubsection}{\numberline {8.0.1}多线程下单例设计模式}{56}% 
\contentsline {subsubsection}{\numberline {8.0.2}为什么在wait代码块中要用while而不用if}{59}% 
\contentsline {subsubsection}{\numberline {8.0.3}Serializable}{64}% 
\contentsline {section}{\numberline {9}附录: 相关样例}{64}% 
\contentsline {subsubsection}{\numberline {9.0.1}小练习}{64}% 
\contentsline {subsubsection}{\numberline {9.0.2}三级标题}{65}% 
\contentsline {subsubsection}{\numberline {9.0.3}第二个三级标题}{65}% 
\contentsline {subsubsection}{\numberline {9.0.4}第三个三级标题}{65}% 
\contentsline {section}{\numberline {10}公式的写作}{65}% 
\contentsline {subsubsection}{\numberline {10.0.1}练习}{65}% 
\contentsline {subsubsection}{\numberline {10.0.2}表格的插入}{66}% 
